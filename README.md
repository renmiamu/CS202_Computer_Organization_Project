# CS202_Computer_Organization

**小组成员：沈泓立、郑袭明、刘安钊**

------

### 开发者说明

| 姓名   | 学号     | 负责内容                                   | 贡献比 |
| ------ | -------- | ------------------------------------------ | ------ |
| 沈泓立 | 12311016 | CPU和IO部分的实现与测试，文档写作          | 1/3    |
| 郑袭明 | 12311011 | CPU硬件测试，VGA，uart，文档写作           | 1/3    |
| 刘安钊 | 12311020 | CPU硬件测试，测试场景1+2汇编代码，文档写作 | 1/3    |

### 开发日程

#### 原计划

- 5.1 - 5.5 CPU子模块实现
- 5.6 - 5.11 CPU顶层模块+子模块测试
- 5.12 - 5.18 测试场景1+2测试
- 5.19 - 5.25 bonus部分实现

#### 实际安排

- 5.1 - 5.5 CPU子模块实现
- 5.6 - 5.11 CPU顶层模块+子模块测试
- 5.12 - 5.18 CPU顶层模块仿真测试
- 5.19 - 5.21 测试场景1通过+VGA
- 5.22 - 5.23 测试场景2通过+uart
- 5.24 文档协作

### CPU架构设计说明

#### CPU特性

**ISA**：

| R-type | opcode  | funct3 | funct7   | 使用方法                |
| ------ | ------- | ------ | -------- | ----------------------- |
| add    | 0110011 | 000    | 000_0000 | rd = rs1 + rs2          |
| sub    | 0110011 | 000    | 010_0000 | rd = rs1 - rs2          |
| xor    | 0110011 | 100    | 000_0000 | rd = rs1 ˆ rs2          |
| or     | 0110011 | 110    | 000_0000 | rd = rs1 \| rs2         |
| and    | 0110011 | 111    | 000_0000 | rd = rs1 & rs2          |
| sll    | 0110011 | 001    | 000_0000 | rd = rs1 « rs2          |
| srl    | 0110011 | 101    | 000_0000 | rd = rs1 » rs2          |
| sra    | 0110011 | 101    | 010_0000 | rd = rs1 » rs2 (Arith*) |
| slt    | 0110011 | 010    | 000_0000 | rd = (rs1 < rs2)?1:0    |
| sltu   | 0110011 | 011    | 000_0000 | rd = (rs1 < rs2)?1:0    |

| I-type-1 | opcode  | funct3 | funct7             | 使用方法                     |
| -------- | ------- | ------ | ------------------ | ---------------------------- |
| addi     | 0010011 | 000    | null               | rd = rs1 + imm               |
| xori     | 0010011 | 100    | null               | rd = rs1 ˆ imm               |
| ori      | 0010011 | 110    | null               | rd = rs1 \| imm              |
| andi     | 0010011 | 111    | Null               | rd = rs1 & imm               |
| slli     | 0010011 | 001    | imm[11:5]=000_0000 | rd = rs1 « imm[4:0]          |
| srai     | 0010011 | 101    | imm[11:5]=010_0000 | rd = rs1 » imm[4:0] (Arith*) |
| srli     | 0010011 | 101    | imm[11:5]=000_0000 | rd = rs1 » imm[4:0]          |

| I-type-2 | opcode  | 使用说明                                                     |
| -------- | ------- | ------------------------------------------------------------ |
| lw       | 0000011 | 在IO输入过程中，我们通过switch取值范围来区分lb, lh, lw, lbu, lhu |

| S-type | opcode  | 使用方法                      |
| ------ | ------- | ----------------------------- |
| sw     | 0100011 | M \[rs1+imm][31:0]= rs2[31:0] |

| B-type | opcode  | funct3 | 使用方法                            |
| ------ | ------- | ------ | ----------------------------------- |
| beq    | 1100011 | 000    | if(rs1 == rs2) PC = PC + {imm,1’b0} |
| bne    | 1100011 | 001    | if(rs1 != rs2) PC = PC + {imm,1’b0} |
| blt    | 1100011 | 100    | if(rs1 < rs2) PC = PC + {imm,1’b0}  |
| bge    | 1100011 | 101    | if(rs1 >= rs2) PC = PC + {imm,1’b0} |
| bltu   | 1100011 | 110    | if(rs1 < rs2) PC = PC + {imm,1’b0}  |
| bgeu   | 1100011 | 111    | if(rs1 >= rs2) PC = PC + {imm,1’b0} |

| J-type | opcode  | 使用方法                        |
| ------ | ------- | ------------------------------- |
| jal    | 1101111 | rd = PC+4; PC = PC + {imm,1’b0} |

| I-type-3 | opcode  | func3 | 使用方法                  |
| -------- | ------- | ----- | ------------------------- |
| jalr     | 1100111 | 000   | rd = PC+4; PC = rs1 + imm |

| U-type | opcode  | 使用方法      |
| ------ | ------- | ------------- |
| lui    | 0110111 | rd = imm « 12 |

| bonus | opcode  | 使用方法             |
| ----- | ------- | -------------------- |
| auipc | 0010111 | rd = PC + (imm « 12) |

**参考的ISA**：RISC-V，具体使用方式请详见RISC-V Reference Card

**寄存器说明**：

​	本项目按照RISC-V 标准定义了 32 个通用寄存器，每个寄存器 32 位宽度：

- x0: 始终为零
- x1-x31: 通用寄存器，用于数据和地址操作

该CPU属于**单周期CPU**，不支持pipeline

**CPU时钟周期**：10kHz

**寻址空间设计**：本系统采用哈佛结构，指令存储与数据存储物理分离。指令空间从 地址 `0x00000000` 开始，数据存储区从地址 `0x00001000` 开始，供程序变量使用；栈空间从地址 `0x00002000` 向下增长，用于函数调用与返回。同时，系统采用 Memory-Mapped I/O 机制，在数据存储空间的高位保留一段地址（ `0xFFFFFF00 ~ 0xFFFFFFFF`）用于内存映射 I/O：数码管地址为 `0xfffffff0`，led地址为 `0xffffffc2` 等。

**外设IO设计**：采用`MMIO`设计方案，根据地址来判断switch读取比特数以及采用LED输出或数码管输出，具体如下：

| IO-input                        | 地址          |
| ------------------------------- | ------------- |
| switch读取`confirm`按钮（1bit） | 32'hffff_ff00 |
| switch读取16位按键              | 32'hffff_fff1 |
| switch读取高8位（unsigned）     | 32'hffff_fff3 |
| switch读取低8位（signed）       | 32'hffff_fff5 |
| switch读取低3位（unsigned）     | 32'hffff_fff7 |
| switch读取低8位（unsigned）     | 32'hffff_fff9 |

| IO-output          | 地址          |
| ------------------ | ------------- |
| 数码管显示16进制数 | 32'hffff_fff0 |
| LED灯亮右侧8个     | 32'hffff_ffc2 |
| 数码管显示10进制数 | 32'hffff_ffc4 |

#### CPU接口

```verilog
module CPU (
    input clk,                  // 原始时钟 100MHz
    input reset,                // 全局复位
    input [15:0] switchInput,   // 来自拨码开关的输入
    input enter,         // 模拟确认按键
    input start_pg,     //recieve data by UART
    input rx,           //send data by UART

    output tx,
    output [7:0] tubSel,        // 数码管位选
    output [7:0] seg_led1234,       // 左侧段选
    output [7:0] seg_led5678,      // 右侧段选
    output [15:0] dataOut
);
```

**时钟信号说明：**在本 CPU 中使用到了开发板提供的 100MHz 时钟 `Y18` ，通过 IP 核分别转化成为了 10kHz（供cpu 使用）、10MHz（供uart使用)

**复位信号说明：**使用异步复位，我们通过高电位信号来判断复位信号并通过开发板的按钮外设来控制复位信号的输入。在按下复位按钮之后， CPU 将会重新回到初始状态，之前的所有状态将会被清空。

**uart接口说明：**UART用于 CPU 与外部设备之间进行数据传输。该接口仅需两根信号线：`rx`（接收端）：接收外部串口数据；`tx`（发送端）：将数据发送到外部设备。通信采用异步传输方式，将inst.txt 和mem.txt生成的out.txt直接烧写到开发版上。

**IO输出接口说明**：led 0-7 号灯根据测试场景可以作为指示信号灯，若判断关系成立则亮灯，反之不亮，也可以展示二进制结果。七段数码管用来显示测试场景中输入的数字和计算后的数字。

### 方案分析说明

#### 浮点数运算在硬件与软件实现上的比较分析

**硬件方案实现：**

在 CPU 指令执行阶段，我们通过手动解析浮点数的 IEEE 754 表示格式，将其符号位、指数位与尾数位逐一提取，并对尾数补齐隐含的最高位“1”，结合指数偏移量进行偏移还原，从而完成对浮点值的还原和整数部分的提取。具体计算中，需根据指数大小对尾数进行左移或右移，以实现乘以或除以2的幂次的效果，从而获得近似的整数值。该方案的显著优势在于：运算过程可完全在 CPU 内部数据通路中完成，无需依赖额外指令序列。

由于浮点数解析涉及较长的组合逻辑路径（如移位器、加减法器、比较器等模块级联），会显著延长关键路径延迟，从而对工作时钟周期造成负面影响。系统的最短时钟周期受限于浮点计算单元的最大延迟，导致整体时钟频率下降，影响 CPU 的主频上限。在采用单周期的情况下，这类组合逻辑路径可能成为系统性能瓶颈。


**软件方案实现：**

我们通过汇编指令模拟浮点数运算。由于本项目 CPU 不直接支持浮点数指令，因此我们采用定点数表示（对二进制小数部分 ×16 放大）来近似处理浮点操作，并在数据存储中以整数方式进行计算和判断。该方案的优势在于开发灵活，调试方便，并能快速通过更新汇编代码完成功能调整。但性能方面相比硬件方案会有所降低，每一次浮点数处理需多条指令完成，且精度受限于整数模拟方法。

**对比结果总结：**

| 比较维度 | 硬件实现                     | 软件实现                         |
| -------- | ---------------------------- | -------------------------------- |
| 性能     | 快速、执行周期短             | 多指令实现，执行时间长           |
| 精度     | 可实现较高精度，取决于电路逻辑设计 | 易受定点数精度影响               |
| 实现难度 | 复杂，需理解底层电路逻辑     | 相对简单，灵活性高               |
| 可调试性 | 需仿真+上板调试，较为困难    | 可直接观察输出结果，易修改和调试 |

**最终选择说明：**

在本次项目中，我们综合考虑开发进度、可靠性与调试成本，选择了**软件实现方案**的方式进行浮点数取整功能的开发。通过先在软件中模拟功能实现。



### 系统上板使用说明

1. **复位** ：复位信号采用开发板上自带的`reset`按钮，当按下后所有的存储数据的变量内的数据会变为初始值并且回到输入测试样例编号的步骤。
2. 最右侧三个按键代表输入的样例编号，按下确定键后进入该样例，通过左侧8个按键输入相应信息。（系统会根据输入地址判断应该读取什么信息）
3. LED或数码管（根据输入的地址）会依据switch的输入内容输出相应的结果。
   - LED灯为store的二进制值
   - 数码管则是十六进制数字或十进制数字

### 自测试说明

| 测试用例 | 测试方法  | 测试类型 |                         测试用例说明                         | 测试结果 |
| :------: | :-------: | :------: | :----------------------------------------------------------: | :------: |
|   1-0    | 仿真+上板 |   单元   |              输入a=2，b=3，LED灯显示二进制编码               |   通过   |
|   1-1    | 仿真+上板 |   单元   |               输入10000001，数码管显示FFFFFF81               |   通过   |
|   1-2    | 仿真+上板 |   单元   |               输入10000001，数码管显示00000081               |   通过   |
|   1-3    | 仿真+上板 |   单元   |                    两数不相等，LED灯不亮                     |   通过   |
|   1-4    | 仿真+上板 |   单元   |                         a<b，LED灯亮                         |   通过   |
|   1-5    | 仿真+上板 |   单元   |                  由于是unsigned，LED灯不亮                   |   通过   |
|   1-6    | 仿真+上板 |   单元   |                   a<b，赋值为1，1个LED灯亮                   |   通过   |
|   1-7    | 仿真+上板 |   单元   |              由于是unsigned，赋值为0，LED灯不亮              |   通过   |
|   2-0    | 仿真+上板 |   集成   |                  输入10101001，输出10010101                  |   通过   |
|   2-1    | 仿真+上板 |   集成   |        输入10000001，LED灯亮；输入10000000，LED灯不亮        |   通过   |
|   2-2    | 仿真+上板 |   集成   | 输入2.5的浮点数，显示十进制数2；输入-2.5的浮点数，显示十进制数-2 |   通过   |
|   2-3    | 仿真+上板 |   集成   |                        两者相加等于0                         |   通过   |
|   2-4    | 仿真+上板 |   集成   |                    输入1000，输出10001011                    |   通过   |
|   2-5    | 仿真+上板 |   集成   |      输入10001011，1个LED灯亮；输入10001010，无LED灯亮       |   通过   |
|   2-6    | 仿真+上板 |   集成   |                   输入12345，显示12345000                    |   通过   |
|   2-7    | 仿真+上板 |   集成   |                  显示1，按下confirm，显示2                   |   通过   |

#### 测试结论

测试用例2-3中没有测试负数和负数相加的情况导致出现了错误，错误的原因是在得到浮点数后先进行了移位后进行了相加，部分小数被忽略，相加可能出现进位问题。代码中改为先相加后移位修复了该问题。

### 开源及AI 对于本次大作业的启发和帮助

> 本次Project借助了网络开源代码以及生成式AI的帮助

**网络开源代码**：在本次开发过程中，我们主要参考了 GitHub 上关于数码管走马灯程序和 VGA 显示模块的开源代码。尽管参考了现有的走马灯程序，但在测试初期，数码管始终无法同时显示 8 个不同的数字。通过逐个关闭数码管进行排查，我们最终发现问题出在 数码管相关的约束（constraint）连接方向相反，导致左四位与右四位数码管始终显示相同的内容。对于 VGA 模块，我们在最初测试时遇到了无法在显示器上正常显示图像的问题。最终通过更换 VGA 线材与显示器，并调整 reset 的复位信号，成功修复了相关代码漏洞，保证了图像的正确输出。

**AI**：鉴于 CPU 模块代码的复杂性，我们小组并未直接使用 AI 生成代码，而是主要借助 AI 提供设计思路与问题排查建议。例如，在测试失败时，我们会向 AI 询问某条指令可能涉及的模块，从而指导我们逐一定位问题。此外，我们也利用 AI 协助编写部分基础指令的测试汇编代码，以提高调试效率，加快基础指令功能的验证过程。

### 问题以及总结

#### 问题

- 时钟周期出现问题导致仿真测试可以通过，但是上板之后数码管一直无法显示
  - 通过调整时钟周期频率解决问题
- 内存无法成功存储输入内容
- 理解IO的输入输出逻辑与测试场景的结合出现困难
- jal和jalr无法正确跳转到正确位置
  - 通过增加pc_out输出保存pc信息
- 起初没有考虑到测试场景2需要能过显示十进制数字

#### 总结

CPU 项目的难点主要在于调试。在这个过程中，你可能需要编写大量汇编代码，并进行多次仿真，才能开始上板测试。仿真时，常常需要逐个变量跟踪排查，才能找出真正出问题的地方，最后整个屏幕都布满了红红绿绿的波形图。

当我们确认仿真没有问题后，还需要花费较长时间等待比特流文件的生成。如果上板测试仍然出错，就只能重新开始整个流程。总之，整个调试过程复杂而漫长，不建议未来的小组把这个项目留到最后几天再完成，否则很可能会因为问题难以定位而彻夜奋战仍无结果。

当然也正因如此，这个项目仍然让我们深入理解并掌握了单周期 CPU 的实现逻辑，收获颇丰。

### Bonus 对应功能点的设计说明

#### 1. 实现扩展指令

##### lui的实现

将立即数左移12位，然后存入rd寄存器，在我们的测试样例中，我们将0x12345，通过lui命令导入寄存器，然后通过sw命令展示在数码管上。

其中的核心代码如下：

```
case6:
    lui t1, 0x12345      # t0 = 0x12345000
    sw t1, 0(s11)        # 输出高位
    jal init
```

该指令在测试场景2-6中得到测试。

##### auipc的实现

将PC左移12位，然后存入rd寄存器，在我们的测试样例中，我们将jalr_target地址，通过auipc命令+addi命令导入寄存器，然后通过jalr命令进行跳转。

其中的核心代码如下：

```
after_jal:
    li a1, 0x2
    la t0, jalr_target        # t0 = jalr_target 地址
    jalr ra, 0(t0)            # 跳转到 jalr_target

    li a1, 0xf         # 若跳转失败执行此行（错误路径）

jalr_target:
    sw a1, 0(s11)             # 输出 a1 = 0x2 到 LED 或数码管地址 
    j init
```

该指令在测试场景2-7中得到测试。

#### 2. uart实现

##### 设计思路

实现 可复用的 UART 程序加载机制：用户只需烧写一次比特流，之后可通过串口动态将不同的 `.inst` 和 `.mem` 文件加载进指令和数据存储模块，灵活切换多个测试场景。

##### 核心配置与代码说明

##### 1. UART IP核添加与配置

- 使用 Vivado IP Catalog 中 `uart_bmpg_v1_3`
- 设置：10MHz 输入时钟、128000 baud、8位数据、1个停止位

##### 2. 新建专用 UART 时钟

- `cpuclk` IP 核中添加新输出 `clk_out2`，频率为 `10 MHz`，用于 UART 通信（图2）
- 由该时钟驱动 UART 模块，使之独立于 CPU 主时钟运行

##### 3. `CPU_TOP` 顶层接口与控制逻辑

- 增加 UART 输入/输出端口：`start_pg`, `rx`, `tx`
- 增加状态管理寄存器 `upg_rst`，通过 `fpga_rst` 与 `start_pg` 控制进入 UART 加载状态（图3-4）
- 定义 `kickOff = upg_rst_i | (~upg_rst_i & upg_done_i)`
  - `kickOff=0`：UART加载状态；
  - `kickOff=1`：正常运行状态

```
  wire upg_clk_o;
    wire upg_wen_o;      //Uart write out enable
    wire upg_done_o;     //Uart rx data have done
    //data to which  memory unit of program_rom/dmemory32 
    wire [14:0] upg_adr_o;     
    //data to program_rom or dmemory32 
    wire [31:0] upg_dat_o; 

    wire spg_bufg;
        
    // de-twitter
    BUFG U1 (.I(start_pg), .O(spg_bufg));
    
    reg upg_rst;
    // UART编程复位信号
    always @(posedge clk) begin
        if (spg_bufg) begin
            upg_rst <= 0;           // UART编程复位信号
        end
        else begin
            upg_rst <= 1;           // UART编程复位信号
        end
    end

    wire rst;      
    assign rst = reset | !upg_rst;

    uart_bmpg_0 uart_prog (
        .upg_clk_i   (upg_clk),      // 分频后的10MHz时钟
        .upg_rst_i   (upg_rst),      // UART复位信号（由 start_pg 生成）
        .upg_rx_i    (rx),           // 串口接收引脚
        .upg_clk_o   (upg_clk_o),    // 输出给其他模块（如 RAM）
        .upg_wen_o   (upg_wen_o),    // 写使能
        .upg_adr_o   (upg_adr_o),    // 写地址（高位用于区分 program/data）
        .upg_dat_o   (upg_dat_o),    // 写数据
        .upg_done_o  (upg_done_o),   // 写入完成标志
        .upg_tx_o    (tx)            // 串口发送引脚（可用于回显等）
    );
```



##### 4. 存储模块适配（ROM / RAM）

- `dmemory32` 和 `programrom` 均支持双输入来源（图5-6）：
  - 正常工作模式下使用 `cpu_clk` 和 `CPU` 的访问信号；
  - UART 模式下使用 `uart_clk` 和 `uart_bmpg` 的地址/数据线。
- 通过 `kickOff` 信号选择数据来源

```

    wire kickOff = upg_rst_i | (~upg_rst_i & upg_done_i);
    
    wire [13:0] ram_addr = kickOff ? addr[15:2] : upg_adr_i;
        
    wire [31:0] ram_data = kickOff ? d_in        : upg_dat_i;
    // 时钟、写使能、地址、写数据，按模式多路选择
    wire ram_we   = kickOff ? m_write     : upg_wen_i;
```

