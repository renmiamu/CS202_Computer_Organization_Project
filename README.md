# CS202_Computer_Organization

**小组成员：沈泓立、郑袭明、刘安钊**

------

### 开发者说明

| 姓名   | 学号     | 负责内容                                   | 贡献比 |
| ------ | -------- | ------------------------------------------ | ------ |
| 沈泓立 | 12311016 | CPU和IO部分的实现与测试，文档写作          | 1/3    |
| 郑袭明 | 12311011 | CPU硬件测试，VGA，uart，文档写作           | 1/3    |
| 刘安钊 | 12311020 | CPU硬件测试，测试场景1+2汇编代码，文档写作 | 1/3    |

### 开发日程

#### 原计划

- 5.1 - 5.5 CPU子模块实现
- 5.6 - 5.11 CPU顶层模块+子模块测试
- 5.12 - 5.18 测试场景1+2测试
- 5.19 - 5.25 bonus部分实现

#### 实际安排

- 5.1 - 5.5 CPU子模块实现
- 5.6 - 5.11 CPU顶层模块+子模块测试
- 5.12 - 5.18 CPU顶层模块仿真测试
- 5.19 - 5.21 测试场景1通过+VGA
- 5.22 - 5.23 测试场景2通过+uart
- 5.24 文档协作

### CPU架构设计说明

#### CPU特性

**ISA**：

| R-type | opcode  | funct3 | funct7   | 使用方法                |
| ------ | ------- | ------ | -------- | ----------------------- |
| add    | 0110011 | 000    | 000_0000 | rd = rs1 + rs2          |
| sub    | 0110011 | 000    | 010_0000 | rd = rs1 - rs2          |
| xor    | 0110011 | 100    | 000_0000 | rd = rs1 ˆ rs2          |
| or     | 0110011 | 110    | 000_0000 | rd = rs1 \| rs2         |
| and    | 0110011 | 111    | 000_0000 | rd = rs1 & rs2          |
| sll    | 0110011 | 001    | 000_0000 | rd = rs1 « rs2          |
| srl    | 0110011 | 101    | 000_0000 | rd = rs1 » rs2          |
| sra    | 0110011 | 101    | 010_0000 | rd = rs1 » rs2 (Arith*) |
| slt    | 0110011 | 010    | 000_0000 | rd = (rs1 < rs2)?1:0    |
| sltu   | 0110011 | 011    | 000_0000 | rd = (rs1 < rs2)?1:0    |

| I-type-1 | opcode  | funct3 | funct7             | 使用方法                     |
| -------- | ------- | ------ | ------------------ | ---------------------------- |
| addi     | 0010011 | 000    | null               | rd = rs1 + imm               |
| xori     | 0010011 | 100    | null               | rd = rs1 ˆ imm               |
| ori      | 0010011 | 110    | null               | rd = rs1 \| imm              |
| andi     | 0010011 | 111    | Null               | rd = rs1 & imm               |
| slli     | 0010011 | 001    | imm[11:5]=000_0000 | rd = rs1 « imm[4:0]          |
| srai     | 0010011 | 101    | imm[11:5]=010_0000 | rd = rs1 » imm[4:0] (Arith*) |
| srli     | 0010011 | 101    | imm[11:5]=000_0000 | rd = rs1 » imm[4:0]          |

| I-type-2 | opcode  | 使用说明                                                     |
| -------- | ------- | ------------------------------------------------------------ |
| lw       | 0000011 | 在IO输入过程中，我们通过switch取值范围来区分lb, lh, lw, lbu, lhu |

| S-type | opcode  | 使用方法                      |
| ------ | ------- | ----------------------------- |
| sw     | 0100011 | M \[rs1+imm][31:0]= rs2[31:0] |

| B-type | opcode  | funct3 | 使用方法                            |
| ------ | ------- | ------ | ----------------------------------- |
| beq    | 1100011 | 000    | if(rs1 == rs2) PC = PC + {imm,1’b0} |
| bne    | 1100011 | 001    | if(rs1 != rs2) PC = PC + {imm,1’b0} |
| blt    | 1100011 | 100    | if(rs1 < rs2) PC = PC + {imm,1’b0}  |
| bge    | 1100011 | 101    | if(rs1 >= rs2) PC = PC + {imm,1’b0} |
| bltu   | 1100011 | 110    | if(rs1 < rs2) PC = PC + {imm,1’b0}  |
| bgeu   | 1100011 | 111    | if(rs1 >= rs2) PC = PC + {imm,1’b0} |

| J-type | opcode  | 使用方法                        |
| ------ | ------- | ------------------------------- |
| jal    | 1101111 | rd = PC+4; PC = PC + {imm,1’b0} |

| I-type-3 | opcode  | func3 | 使用方法                  |
| -------- | ------- | ----- | ------------------------- |
| jalr     | 1100111 | 000   | rd = PC+4; PC = rs1 + imm |

| U-type | opcode  | 使用方法      |
| ------ | ------- | ------------- |
| lui    | 0110111 | rd = imm « 12 |

| bonus | opcode  | 使用方法             |
| ----- | ------- | -------------------- |
| auipc | 0010111 | rd = PC + (imm « 12) |

**参考的ISA**：RISC-V，具体使用方式请详见RISC-V Reference Card

**寄存器说明**：

​	本项目按照RISC-V 标准定义了 32 个通用寄存器，每个寄存器 32 位宽度：

- x0: 始终为零
- x1-x31: 通用寄存器，用于数据和地址操作

该CPU属于**单周期CPU**，不支持pipeline

**CPU时钟周期**：

**寻址空间设计**：

**外设IO设计**：采用`MMIO`设计方案，根据地址来判断switch读取比特数以及采用LED输出或数码管输出，具体如下：

| IO-input                        | 地址          |
| ------------------------------- | ------------- |
| switch读取`confirm`按钮（1bit） | 32'hffff_ff00 |
| switch读取16位按键              | 32'hffff_fff1 |
| switch读取高8位（unsigned）     | 32'hffff_fff3 |
| switch读取低8位（signed）       | 32'hffff_fff5 |
| switch读取低3位（unsigned）     | 32'hffff_fff7 |
| switch读取低8位（unsigned）     | 32'hffff_fff9 |

| IO-output          | 地址          |
| ------------------ | ------------- |
| 数码管显示16进制数 | 32'hffff_fff0 |
| LED灯亮右侧8个     | 32'hffff_ffc2 |
| 数码管显示10进制数 | 32'hffff_ffc4 |

#### CPU接口

```verilog
module CPU (
    input clk,                  // 原始时钟 100MHz
    input reset,                // 全局复位
    input [15:0] switchInput,   // 来自拨码开关的输入
    input enter,         // 模拟确认按键
    input start_pg,     //recieve data by UART
    input rx,           //send data by UART

    output tx,
    output [7:0] tubSel,        // 数码管位选
    output [7:0] seg_led1234,       // 左侧段选
    output [7:0] seg_led5678,      // 右侧段选
    output [15:0] dataOut
);
```

**时钟信号说明：**

**复位信号说明：**

**uart接口说明：**

**IO输出接口说明**：

### 方案实现说明

### 系统上板使用说明

1. **复位** ：复位信号采用开发板上自带的`reset`按钮，当按下后所有的存储数据的变量内的数据会变为初始值并且回到输入测试样例编号的步骤。
2. 最右侧三个按键代表输入的样例编号，按下确定键后进入该样例，通过左侧8个按键输入相应信息。（系统会根据输入地址判断应该读取什么信息）
3. LED或数码管（根据输入的地址）会依据switch的输入内容输出相应的结果。
   - LED灯为store的二进制值
   - 数码管则是十六进制数字或十进制数字

### 自测试说明

| 测试用例 | 测试方法  | 测试类型 |                         测试用例说明                         | 测试结果 |
| :------: | :-------: | :------: | :----------------------------------------------------------: | :------: |
|   1-0    | 仿真+上板 |   单元   |              输入a=2，b=3，LED灯显示二进制编码               |   通过   |
|   1-1    | 仿真+上板 |   单元   |               输入10000001，数码管显示FFFFFF81               |   通过   |
|   1-2    | 仿真+上板 |   单元   |               输入10000001，数码管显示00000081               |   通过   |
|   1-3    | 仿真+上板 |   单元   |                    两数不相等，LED灯不亮                     |   通过   |
|   1-4    | 仿真+上板 |   单元   |                         a<b，LED灯亮                         |   通过   |
|   1-5    | 仿真+上板 |   单元   |                  由于是unsigned，LED灯不亮                   |   通过   |
|   1-6    | 仿真+上板 |   单元   |                   a<b，赋值为1，1个LED灯亮                   |   通过   |
|   1-7    | 仿真+上板 |   单元   |              由于是unsigned，赋值为0，LED灯不亮              |   通过   |
|   2-0    | 仿真+上板 |   集成   |                  输入10101001，输出10010101                  |   通过   |
|   2-1    | 仿真+上板 |   集成   |        输入10000001，LED灯亮；输入10000000，LED灯不亮        |   通过   |
|   2-2    | 仿真+上板 |   集成   | 输入2.5的浮点数，显示十进制数2；输入-2.5的浮点数，显示十进制数-2 |   通过   |
|   2-3    | 仿真+上板 |   集成   |                        两者相加等于0                         |   通过   |
|   2-4    | 仿真+上板 |   集成   |                    输入1000，输出10001011                    |   通过   |
|   2-5    | 仿真+上板 |   集成   |      输入10001011，1个LED灯亮；输入10001010，无LED灯亮       |   通过   |
|   2-6    | 仿真+上板 |   集成   |                   输入12345，显示12345000                    |   通过   |
|   2-7    | 仿真+上板 |   集成   |                                                              |          |

#### 测试结论



### 开源及AI 对于本次大作业的启发和帮助

> 本次Project借助了网络开源代码以及生成式AI的帮助

**网络开源代码**：在本次开发过程中，我们主要参考了 GitHub 上关于数码管走马灯程序和 VGA 显示模块的开源代码。尽管参考了现有的走马灯程序，但在测试初期，数码管始终无法同时显示 8 个不同的数字。通过逐个关闭数码管进行排查，我们最终发现问题出在 数码管相关的约束（constraint）连接方向相反，导致左四位与右四位数码管始终显示相同的内容。对于 VGA 模块，我们在最初测试时遇到了无法在显示器上正常显示图像的问题。最终通过更换 VGA 线材与显示器，并调整 reset 的复位信号，成功修复了相关代码漏洞，保证了图像的正确输出。

**AI**：鉴于 CPU 模块代码的复杂性，我们小组并未直接使用 AI 生成代码，而是主要借助 AI 提供设计思路与问题排查建议。例如，在测试失败时，我们会向 AI 询问某条指令可能涉及的模块，从而指导我们逐一定位问题。此外，我们也利用 AI 协助编写部分基础指令的测试汇编代码，以提高调试效率，加快基础指令功能的验证过程。

### 问题以及总结

#### 问题

- 时钟周期出现问题导致仿真测试可以通过，但是上板之后数码管一直无法显示
  - 通过调整时钟周期频率解决问题
- 内存无法成功存储输入内容
- 理解IO的输入输出逻辑与测试场景的结合出现困难
- jal和jalr无法正确跳转到正确位置
  - 通过增加pc_out输出保存pc信息
- 起初没有考虑到测试场景2需要能过显示十进制数字

#### 总结

CPU 项目的难点主要在于调试。在这个过程中，你可能需要编写大量汇编代码，并进行多次仿真，才能开始上板测试。仿真时，常常需要逐个变量跟踪排查，才能找出真正出问题的地方，最后整个屏幕都布满了红红绿绿的波形图。

当我们确认仿真没有问题后，还需要花费较长时间等待比特流文件的生成。如果上板测试仍然出错，就只能重新开始整个流程。总之，整个调试过程复杂而漫长，不建议未来的小组把这个项目留到最后几天再完成，否则很可能会因为问题难以定位而彻夜奋战仍无结果。

当然也正因如此，这个项目仍然让我们深入理解并掌握了单周期 CPU 的实现逻辑，收获颇丰。